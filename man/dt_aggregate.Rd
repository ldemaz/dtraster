% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/dt_aggregate.R
\name{dt_aggregate}
\alias{dt_aggregate}
\title{Spatial aggregation of data.table.raster}
\usage{
dt_aggregate(xdt, nr, nc, fact, funexpr, dxy, outname, dropid = TRUE)
}
\arguments{
\item{nr}{Number of rows in data.table.raster}

\item{nc}{Number of columns in data.table.raster}

\item{fact}{aggregation factor}

\item{funexpr}{Aggregation function for data.table to evaluate (see details)}

\item{dxy}{Resolution of input data.table.raster (square grids only)}

\item{outname}{Character vector for value to be aggregated}

\item{dropid}{Keep or remove cell number ID in output data.table.raster?}

\item{dt}{Input data.table, with x, y coordinates}
}
\value{
An aggregated data.table.raster
}
\description{
Spatial aggregation of data.table.raster
}
\details{
This function was created to allow more complicated aggregations,
such as weighted mean aggregation. Functions need to be passed in as an
expression, complete with the names of the variables to evaluate. E.g. for
a data.table.raster with variables x and w, then pass in
funexpr = parse(text = "weighted.mean(x, w)"). Aggregation will always be
done by variables ac and ar, which indicate the aggregation groupings.
Don't name one of your variables x, because as.data.table.raster creates
a x coordinate, and the function will fail if it detects a duplicate column
name.
}
\examples{
r1 <- raster(xmn = 10, xmx = 20, ymn = 10, ymx = 20)
res(r1) <- 0.25
set.seed(1)
r1[] <- sample(1:10, ncell(r1), replace = TRUE)
r2 <- raster(r1)
set.seed(3)
r2[] <- runif(ncell(r2), min = 0, max = 1)
s <- stack(r1, r2)
names(s) <- c("v", "w")  # selecting name v, rather than x.
rdt <- as.data.table.raster(s, xy = TRUE)
p4s <- CRS(projection(r1))
plot(dt_to_raster(rdt, p4s))
vw <- dt_aggregate(x = rdt, nr = nrow(r1), nc = ncol(r1), fact = 5,
                   funexpr = parse(text = "weighted.mean(v, w)"),
                   dxy = xres(r1), outname = "muw")
v <- dt_aggregate(rdt, nr = nrow(r1), nc = ncol(r1), fact = 5,
                  funexpr = parse(text = "mean(v)"),
                  dxy = xres(r1), outname = "mu")
plot(dt_to_raster(vw, p4s))
plot(dt_to_raster(v, p4s))
plot(aggregate(r1, fact = 5))
plot(aggregate(r1, fact = 5) - dt_to_raster(v, p4s)) # r inferno
plot(round(aggregate(r1, fact = 5) - dt_to_raster(v, p4s), 10)) # same

# speed test
r3 <- raster(xmn = 10, xmx = 20, ymn = 10, ymx = 20)
p4s <- CRS(projection(r3))
res(r3) <- 0.001
set.seed(1)
r3[] <- sample(1:10, ncell(r3), replace = TRUE)
names(r3) <- "v"  # selecting name v, rather than x.
rdt <- as.data.table(r3, xy = TRUE)  # time penalty to convert to data.table
system.time(v <- dt_aggregate(rdt, nr = nrow(r3), nc = ncol(r3), fact = 10,
                              funexpr = parse(text = "mean(v)"),
                              dxy = xres(r3), outname = "mu"))
# user  system elapsed
# 11.328  16.006  35.346
system.time(r4 <- aggregate(r3, fact = 10))
# user  system elapsed
# 2.240   1.183   4.159 # raster aggregate still much faster
dtr <- dt_to_raster(v, p4s)
plot(dtr)
plot(r4)
plot(round(dtr - r4), 10)
}

